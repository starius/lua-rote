{"name":"Lua-rote","tagline":"Lua binding to ROTE, Terminal Emulation library","body":"# lua-rote, Lua binding to ROTE, Terminal Emulation library\r\n\r\n[![Build Status](https://travis-ci.org/starius/lua-rote.png?branch=master)](https://travis-ci.org/starius/lua-rote)\r\n[![Coverage Status](https://coveralls.io/repos/starius/lua-rote/badge.png?branch=master)](https://coveralls.io/r/starius/lua-rote?branch=master)\r\n[![License](http://img.shields.io/badge/License-LGPL2.1-brightgreen.png)][4]\r\n\r\n## Description\r\n\r\n[ROTE][1] is a simple C library for VT102 terminal emulation.\r\nIt allows the programmer to set up virtual 'screens' and send\r\nthem data. The virtual screens will emulate the behavior of a\r\nVT102 terminal, interpreting escape sequences, control\r\ncharacters and such. The library supports ncurses as well so\r\nthat you may render the virtual screen to the real screen\r\nwhen you need to.\r\n\r\nThere are several programs that do terminal emulation, such\r\nas xterm, rxvt, screen and even the Linux console driver\r\nitself. However, it is not easy to isolate their terminal\r\nemulation logic and put it in a module that can be easily\r\nreused in other programs. That's where the ROTE library\r\ncomes in.\r\n\r\nThe goal of the lua-rote library is to provide terminal\r\nemulation support for Lua applications, making it\r\npossible to write programs that display terminals in\r\nembedded windows within them, or even monitor the display\r\nproduced by other programs. The lua-rote library depend\r\nonly on Lua, ROTE itself, ncurses and luaposix.\r\n\r\nThe ROTE library is able to render the\r\nvirtual screens to the physical screen (actually any\r\nncurses window) and can also translate ncurses key codes to\r\nthe escape sequences the Linux console would have produced\r\n(and feed them into the terminal). Using ncurses is not\r\nmandatory however, and ROTE will work fine without it, but\r\nin that case the application must take care of drawing the\r\nterminal to the screen in whichever way it sees fit.\r\n\r\nROTE also encapsulates the functionality needed to execute\r\na child process using the virtual screen as the controlling\r\nterminal. It will handle the creation of the\r\npseudo-terminal and the child process. All the application\r\nhas to do is tell it the command to run in the terminal and\r\ncall an update function at regular intervals to allow the\r\nterminal to update itself.\r\n\r\nROTE is extremely useful to programmatically interact\r\nwith curses applications (e.g., for unit testing).\r\n\r\n## Prerequisites\r\n\r\n - Lua 5.1, 5.2, 5.3 or LuaJIT\r\n - curses (binary + headers)\r\n - luaposix (install after installing curses headers!)\r\n - [ROTE][1] (install after installing curses headers!)\r\n\r\n> Curses and luaposix are needed for drawing state of ROTE\r\n> terminal on curses' WINDOW object\r\n> (method [RoteTerm:draw()](#draw)).\r\n> If you do not need this feature and want to exclude these\r\n> two dependencies, then remove CURSES and luaposix from\r\n> file `lua-rote-*.rockspec`.\r\n\r\nSee [shell script][5] with installation\r\ncommands for Debian Wheezy.\r\n\r\n## Installation\r\n\r\nThis library is built using [LuaRocks](http://luarocks.org).\r\n\r\n### Option 1: install from LuaRocks server\r\n\r\n```bash\r\n$ luarocks install lua-rote\r\n```\r\n\r\nIf you have installed ROTE to prefix other than \"/usr\",\r\nyou have to provide this path to LuaRocks.\r\nFor example, if you have installed ROTE to \"/usr/local\",\r\nuse the following command:\r\n\r\n```bash\r\n$ luarocks install lua-rote ROTE_DIR=/usr/local\r\n```\r\n\r\n### Option 2: install from local source tree\r\n\r\n```bash\r\n$ git clone https://github.com/starius/lua-rote.git\r\n$ cd lua-rote\r\n$ luarocks make\r\n```\r\n\r\n## Running unit tests\r\n\r\nUnit tests are written using unit testing framework\r\n[busted](http://olivinelabs.com/busted/).\r\nUnit tests can serve as reference documentation and\r\ncode examples.\r\n\r\nTo run unit tests, install busted from LuaRocks:\r\n\r\n```bash\r\n$ luarocks install busted\r\n```\r\n\r\nGo to the source folder of lua-rote and run command `busted`:\r\n\r\n```bash\r\n$ busted\r\n++++++++++++++++++++++++++++++++\r\n32 successes / 0 failures / 0 errors / 0 pending : 1.5 seconds\r\n```\r\n\r\n## Running the demo\r\n\r\nProgram [boxshell.lua][6] is a clone of\r\nROTE's example program \"boxshell.c\" (file \"demo/boxshell.c\"\r\nin ROTE's source tree).\r\nBoth programs include the following steps:\r\n\r\n - start curses,\r\n - fill the screen with blue,\r\n - create curses window in the middle of the screen,\r\n - start ROTE terminal, fork bash inside,\r\n - do in a loop until child process dies:\r\n    - redraw curses window accorsing to ROTE terminal,\r\n    - `getch()`, results of which are passed to ROTE terminal.\r\n\r\nRun `lua demo/boxshell.lua`, `ls`, `busted`:\r\n\r\n![boxshell.lua](http://i.imgur.com/F5K9gJt.png)\r\n\r\n> Currently lua-rote does not support unicode characters,\r\n> that is why busted was changed to produce \"+\" instead of \"●\".\r\n\r\n> There are some differences between boxshell.c and\r\n> boxshell.lua. Program boxshell.lua can fork other commands\r\n> as well as bash. boxshell.c uses `nodelay` mode\r\n> repeating draw-getch cycle without a delay,\r\n> while boxshell.lua uses `halfdelay` mode repeating\r\n> draw-getch cycle 10 times a second.\r\n> That is why boxshell.c constantly consumes 100% CPU,\r\n> while boxshell.lua consumes almost no CPU when inactive.\r\n\r\n## Reference\r\n\r\n### Module rote\r\n\r\nLibrary lua-rote is loaded from module \"rote\":\r\n\r\n```lua\r\nrote = require 'rote'\r\n```\r\n\r\nAll code of the library \"lives\" inside this module.\r\n\r\n### Class RoteTerm\r\n\r\nThe main part of the library is class RoteTerm.\r\nIt wraps C structure RoteTerm, declared in library ROTE.\r\nRoteTerm represents terminal emulator.\r\n\r\nCreate a new virtual terminal with the given dimensions.\r\n(Height is 24 rows, width is 80 columns.)\r\n\r\n```lua\r\nrt = rote.RoteTerm(24, 80)\r\n```\r\n\r\nInstance of RoteTerm is destroyed automatically\r\nwhen the corresponding Lua object is collected.\r\n\r\n### Start child process\r\n\r\nStart a forked process in the terminal:\r\n\r\n```lua\r\npid = rt:forkPty('less /some/file')\r\n```\r\n\r\nThe command will be interpreted by '/bin/sh -c'.\r\n\r\nReturns PID of the child process.\r\nOn error returns `-1`.\r\nNotice that passing an invalid command will not cause\r\nan error at this level: the shell will try to execute\r\nthe command and will exit with status 127. You can catch\r\nthat by installing a `SIGCHLD` handler if you want.\r\n\r\n> If you want to be notified when child processes exits,\r\n> you should handle the `SIGCHLD` signal.\r\n> If, on the other hand, you want to ignore exitting\r\n> child processes, you should set the `SIGCHLD` handler to\r\n> `SIG_IGN` to prevent child processes from hanging\r\n> around the system as 'zombie processes'.\r\n>\r\n> You can use luaposix to manage child processes as described\r\n> above. See file [demo/boxshell.lua][6].\r\n>\r\n> Continuing to write to a RoteTerm whose child process\r\n> has died does not accomplish a lot, but is not an error\r\n> and should not cause your program to crash or block\r\n> indefinitely or anything of that sort :-)\r\n>\r\n> If, however, you want to be tidy and inform the RoteTerm\r\n> that its child has died, call method `forsakeChild`\r\n> when appropriate.\r\n\r\nYou can get the PID later by calling `rt:childPid()`.\r\n\r\nDisconnect the RoteTerm from its forked child process:\r\n\r\n```lua\r\nrt:forsakeChild()\r\n```\r\n\r\n### Getting contents of the terminal\r\n\r\nYou can get number of rows and columns of the terminal:\r\n\r\n```lua\r\nprint(rt:rows()) -- integer\r\nprint(rt:cols()) -- integer\r\n```\r\n\r\nGet cursor coordinates:\r\n\r\n```lua\r\nprint(rt:row()) -- integer\r\nprint(rt:col()) -- integer\r\n```\r\n\r\nBefore getting any output from the child process, call method\r\n`rt:update()` to update internal state of RoteTerm.\r\n\r\nYou can get value of character and attribute of any cell:\r\n\r\n```lua\r\nrow = 0\r\ncol = 0\r\nprint(rt:cellChar(row, col)) -- string of length 1\r\nattr = rt:cellAttr(row, col) -- integer\r\n```\r\n\r\nlua-rote provides [several functions](#handling-attributes)\r\nto handle attribute values.\r\n\r\nGet current attribute, that is the attribute that will be\r\nused for newly characters:\r\n\r\n```lua\r\nprint(rt:attr()) -- integer\r\n```\r\n\r\nGet a row as a string (not terminated with `\\n`):\r\n\r\n```lua\r\nrow = 0\r\nprint(rt:rowText(row)) -- string\r\n```\r\n\r\nGet whole terminal as a string (rows are terminated with `\\n`):\r\n\r\n```lua\r\nprint(rt:termText()) -- string\r\n```\r\n\r\n<a name=\"draw\" id=\"draw\"></a>\r\nDraw contents of ROTE terminal on curses WINDOW:\r\n\r\n```lua\r\ncurses = require 'posix.curses'\r\n-- setup curses, see demo/boxshell.lua\r\nwindow = ...\r\nrt = ...\r\nstart_row = 0\r\nstart_col = 0\r\nrt:draw(window, start_row, start_col)\r\n```\r\n\r\n### Changing the terminal state\r\n\r\nYou can directly change internal state of RoteTerm by\r\ncalling the following methods:\r\n\r\n```lua\r\nrt:setCellChar(row, col, character) -- character at (row, col)\r\nrt:setCellAttr(row, col, attr) -- attribute at (row, col)\r\nrt:setAttr(attr) -- current attribute\r\n```\r\n\r\nYou can pass data to the child process or to the terminal:\r\n\r\n```lua\r\n-- Puts data ':wq\\n' into the terminal.\r\n-- If there is a forked process, the data will be sent to it.\r\n-- If there is no forked process, the data will simply\r\n-- be injected into the terminal (as in inject()).\r\nrt:write(':wq\\n')\r\n\r\n-- Inject data directly into the terminal.\r\nrt:inject(':wq\\n')\r\n\r\n-- Indicates to the terminal that the key has been pressed.\r\n-- Appropriate escape sequence is passed to method write().\r\nlocal keycode = string.byte('\\n') -- integer\r\nrt:keyPress(keycode)\r\n```\r\n\r\nYou can get values of keycodes from [posix.curses][3].\r\n\r\n### Snapshots\r\n\r\n```lua\r\n-- take a snapshot of the current contents of the terminal\r\nsnapshot = rt:takeSnapshot()\r\n-- ... do something ...\r\n-- restore a snapshot previously taken\r\nrt:restoreSnapshot(snapshot)\r\n```\r\n\r\nSnapshot object is deleted automatically when the\r\ncorresponding Lua object is collected.\r\n\r\n<a name=\"handling-attributes\" id=\"handling-attributes\"></a>\r\n\r\n### Handling attributes\r\n\r\nAn 'attribute' as used in this library means an 8-bit value\r\nthat conveys a foreground color code, a background color code,\r\nand the bold and blink bits. Each cell in the virtual terminal\r\nscreen is associated with an attribute that specifies\r\nits appearance.\r\n\r\nThe bits of an attribute, from most significant to\r\nleast significant, are\r\n\r\n```\r\n bit:      7 6 5 4 3 2 1 0\r\n content:  S F F F H B B B\r\n           | `-,-' | `-,-'\r\n           |   |   |   |\r\n           |   |   |   `----- 3-bit background color (0 - 7)\r\n           |   |   `--------- blink bit\r\n           |   `------------- 3-bit foreground color (0 - 7)\r\n           `----------------- bold bit\r\n```\r\n\r\n\r\nColor codes:\r\n\r\n - 0 = black,\r\n - 1 = red,\r\n - 2 = green,\r\n - 3 = yellow,\r\n - 4 = blue,\r\n - 5 = magenta,\r\n - 6 = cyan,\r\n - 7 = white.\r\n\r\nThere are functions provided to \"pack\" and \"unpack\"\r\nattribute bits:\r\n\r\n```lua\r\nforeground, background, bold, blink = rote.fromAttr(attr)\r\nattr = rote.toAttr(foreground, background, bold, blink)\r\n-- foreground and background are integers (0 - 7)\r\n-- bold and blink are booleans\r\n```\r\n\r\nThe library provides tables converting color codes to and from\r\nhuman readable names:\r\n\r\n```lua\r\nprint(rote.color2name[2]) -- prints \"green\"\r\nprint(rote.name2color.green) -- prints \"2\"\r\n```\r\n\r\n## Bugs\r\n\r\n - Unicode characters are printed and read with errors.\r\n - Method `RoteTerm:draw()` is [unreliable][2].\r\n - ROTE can't read cell 0x0 in 1x2 window when\r\n    reads second time. It seems to be related to\r\n    low number of columns.\r\n\r\n[Report a bug][7]\r\n\r\n## Author\r\n\r\nCorresponding author: Boris Nagaev, email: bnagaev@gmail.com\r\n\r\nCopyright (C) 2015 Boris Nagaev\r\n\r\nSee the [LICENSE][4] file for terms of use.\r\n\r\nROTE was written by Bruno T. C. de Oliveira,\r\nsee [rote.sourceforge.net][1] for more information.\r\n\r\n## Links\r\n\r\n - [Home page][13]\r\n - [ROTE][1]\r\n - [Report a bug][7]\r\n - [Reddit][8]\r\n - [Хабрахабр][9]\r\n - [lua-l][12]\r\n - [Busted][10]\r\n - [lua-travis-example][11]\r\n\r\n[1]: http://rote.sourceforge.net/\r\n[2]: https://travis-ci.org/starius/lua-rote/jobs/54479120#L1160\r\n[3]: https://luaposix.github.io/luaposix/modules/posix.curses.html\r\n[4]: https://github.com/starius/lua-rote/blob/master/LICENSE\r\n[5]: https://github.com/starius/lua-rote/blob/master/.travis/install_rote.sh\r\n[6]: https://github.com/starius/lua-rote/blob/master/demo/boxshell.lua\r\n[7]: https://github.com/starius/lua-rote/issues/new\r\n[8]: https://www.reddit.com/r/lua/comments/30ast4/ann_luarote_lua_binding_to_rote_terminal/\r\n[9]: http://habrahabr.ru/post/254089/\r\n[10]: http://olivinelabs.com/busted/\r\n[11]: https://github.com/moteus/lua-travis-example\r\n[12]: http://lua-users.org/lists/lua-l/2015-03/msg00325.html\r\n[13]: http://starius.github.io/lua-rote","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}